---
title: "[Paper Review] MILo: Mesh-In-the-Loop Gaussian Splatting for Detailed and Efficient Surface Reconstruction"
date: "2026-01-05 18:00:00 +0900"
categories: ["Paper Review"]
tags: ["Paper Review"]
math: true
---

Author: [Antoine Guédon](https://arxiv.org/search/cs?searchtype=author&query=Guédon,+A), [Diego Gomez](https://arxiv.org/search/cs?searchtype=author&query=Gomez,+D), [Nissim Maruani](https://arxiv.org/search/cs?searchtype=author&query=Maruani,+N), [Bingchen Gong](https://arxiv.org/search/cs?searchtype=author&query=Gong,+B), [George Drettakis](https://arxiv.org/search/cs?searchtype=author&query=Drettakis,+G), [Maks Ovsjanikov](https://arxiv.org/search/cs?searchtype=author&query=Ovsjanikov,+M)

[[github]](https://github.com/Anttwo/MILo?tab=readme-ov-file) [[page]](https://anttwo.github.io/milo)  [[paper]](https://arxiv.org/abs/2506.24096)  [[Presentation video]](https://www.youtube.com/watch?v=rOBs2yyYaJM)[[Data]](https://drive.google.com/drive/folders/1Bf7DM2DFtQe4J63bEFLceEycNf4qTcqm?usp=sharing)



### 1 Introduction

---

![Figure 1](./assets/img/Paper-Review/MILo/Figure1.webp)

지금까지의 이미지들을 기반으로 mesh를 생성하는 방법론은 대부분 2가지 pipeline을 채택합니다.

1. 미분가능한 렌더링을 통한 volumetric representation을 최적화
2. 주로 isosurface를 사용하여 surface를 정의함으로써 postprocessing동안 surface mesh를 추출

이러한 방법론들은 최적화동안 mesh reconstruction을 고려하지 않습니다. 이 방식들은 final mesh가 volumetric representation과 동일할것이란 것을 보장하지 않으며 representation을 렌더링할때 미세한 디테일이 손실될 수 있습니다. 이로 인하여 이 postprocessing step에서 표면에서의 복잡한 volumetric information을 붕괴시켜, 종종 미세하거나 반투명한 구조의 손실을 야기하고 추출된 메시에 artifacts가 생길 수 있습니다. 



3DGS와 NeRF는 geometry의 opacity와 view-dependent colors를 조정하기 때문에 geometric consistency를 소실하게 되어 mesh extract를 더 어렵게 만듭니다. 그리고 대부분의 방법론들은 foreground의 quality만 평가하고 background의 quality는 무시하는 경향이 있습니다.

그래서 MILo는 일정한 training iteration마다 gaussians의 point set 기반으로 mesh를 생성하는 Gaussian Pivots을 제안합니다. Gaussian Pivots은 surface mesh와 volumetric field사이의 consistency를 맞추기 위해서 훈련 중 mesh에서 Gaussian parameters를 바로 gradient backpropagation이 가능하게 해줍니다. 추가적으로 output의 complexity을 제어하기 위해서 새로운 densification과 simplification strategies를 제안합니다.

새로운 densification과 simplification strategies으로 인하여 훨씬 적은 vertices으로 더 실용적이면서 SOTA geometric quality를 달성합니다. MILo는 GT가 존재하지 않는 background에서는 mesh rendering에 기반한 proxy metric을 사용합니다. 이를 위해 mesh의 neural color field를 학습하여 렌더링된 이미지를 비교합니다.

요약하면 다음과 같습니다.

1.  학습과정에서 mesh extract하여 3D Gaussian의 파라미터로 optimization을 진행
2.  mesh 기반의 regularization strategies를 제안
3.  surface-based view synthesis에서 도입된 metric를 채택하여 geometry를 평가하기 위한 평가 프로토콜로 사용

### 3 Overview

---

MILO는 optimization process에 mesh extraction을 통합함으로써 volumetric과 surface representations의 consistent를 보장합니다.

일정한 training iteration마다 extracting mesh를 수행하여 Gaussians의 back-propagating gradients를 수행합니다.

![Figure 2](./assets/img/Paper-Review/MILo/Figure2.webp)

MILo는 5개의 main steps으로 이루어져 있습니다.

1. trainable Delaunay vertices를 가져옵니다
2. Delaunay triangulation을 update 합니다.
3. 각각의 Delaunay vertex의 trainable signed distance values를 가져옵니다.
4. GPU-based differentiable Marching Tetrahedra를 적용하여 mesh extraction을 수행합니다.
5. 동시에 추출된 mesh와 3D Gaussian을 렌더링하여 Gaussian 파라미터에 image-based and consistence losses를 계산하여 Back-propagate를 수행합니다.

최적화하는 동안에,MILo는 3D Gaussian에 인코딩된 기하학과 추출된 surface가 일치하도록 장려하기 위해,volumetric과 surface의 normal과 depth를 렌더링하고 비교합니다.

###  4 Differentiable Mesh Extraction

---

해당 section에서는 optimization 과정중에 gaussian 파라미터에 gradients를 전달할 수 있는 자세한 differentiable mesh extraction에 대해서 제공합니다.

#### 4.1 Sampling Delaunay Vertices from Gaussians

첫번째 단계는 Delaunay triangulation의 vertices로 적절한 points를 3D space로부터 판별합니다. 모든 Gaussian의 center를 Delaunay triangulation의 vertices로 사용하는 단순한 접근법은 두가지 한계를 가집니다.

1. marching tetrahedra를 효과적으로 적용하기 위해서는 표면을 가로지르는 Delaunay vertices가 필요하지만 Gaussians의 center는 일반적으로 surface위나 근처에 위치합니다.
2. large scenes에서 모든 Gaussian을 Delaunay vertices로 사용하는 것은 너무 큰 비용이 듭니다.

이를 해결하기 위해, MILo는 gaussian당 9개의 점을 샘플링합니다. 9개의 점은 gaussian center와 principal axes에 정렬된 8개의 corner points로 정의합니다. 이는 bounding box의 vertices와 center를 scaling과 reotating 함으로써 얻을 수 있습니다.
$$
\mathbf{p}_{k,i} = \boldsymbol{\mu}_k + \mathbf{R}_k \left( \mathbf{s}_k \odot \mathbf{b}_i \right),
\quad i = 0, \ldots, 8
$$
여기서 \( \odot \)은 Hadamard product 입니다.

이 전략은 앞서 설명한 1번째 한계를 해결할 수 있습니다

scalability challenge를 해결하기 위해 MILo는 오직 surface 근처에 있는 Gaussian으로부터 Delaunay vertices를 샘플링하는 전략을 제안합니다. 이를 하기위해 MILo는 모든 training views에 걸쳐 rendering에 대한 Gaussians의 blending coefficients의 평균을 중요도로 하여 순위를 매기는 importance-weighted sampling을 활용합니다.  이로 인하여 장면의 geometric structure와 미세한 디테일을 보존하는 gaussian set을 선택할 수 있습니다. mesh regularization으로부터 직접적인 gradient를 받는것은 선택된 gaussian 뿐이지만 3DGS의 렌더링과 Mesh 렌더링간의 consistency를 부여하기 때문에 모든 gaussian이 제약을 받습니다. 선택된 gaussian만이 gradient를 받기때문에 매우 효율적입니다.

해당 MILo는 두가지 모델을 선보입니다.

**Base model**: 중요도 기반 sampling 전략을 통하여 선택받지 못한 gaussian은 모두 삭제됩니다. 그리고 주기적인 iteration마다 남아있는 gaussian 기반으로 mesh extraction을 수행합니다. 그 결과 매우 효율적이고 높은 퀄리티의 gaussian을 얻게됩니다.

**Dense model**: 중요도 기반 sampling 전략을 채택하지만 선택받지 못한 Gaussian은 남겨둡니다. 선택받는 gaussian의 수는 base model과 거의 유사합니다. 그래서 여전히 가벼운 mesh를 생성하지만, 더 많은 gaussian은 이 vertices에 더 나은 SDF값을 학습하는 데 도움을 줍니다. optimization은 더 오래걸리지만 더 좋은 성능을 냅니다.

이렇게 Delaunay vertices를 획득한 후, 다음 단계에서 필요한 tetrahedralization을 제공하는 Delaunay triangulation을 계산합니다.

#### 4.2 Computing Signed Distance Values

Delaunay triangulation을 계산하기 위해서 MILo는 Marching Tetrahedra algorithm을 채택합니다. 이 알고리즘은 SDF로부터 파생된 스칼라값으로 augmented tetrahedra grid를 필요로 합니다.  이를 위해서 Delaunay vertex에 singed scalar value를 할당해야합니다. 비록 이 값들은 진짜 SDF로부터 얻은건 아니지만 편의상 SDF 값으로 칭합니다. 각 가우시안 마다 optimizable SDF values 9개를 증강합니다.\( f_k \in \mathbb{R}^9 \)

중요한것은 이 9개의 SDF values는 다른 Gaussian 파라미터들과 독립적입니다. 이 특성은 volumetric과 mesh representation간의 consistency를 보장하며 미세한 surface을 정확하게 담아낼 수 있습니다. 

그리고 더 빠른 수렴을 위해서 MILo는 custom initialization algorithm을 제안합니다. 



#### 4.3 Differentiable Marching Tetrahedra

Delaunay vertices와 SDF values가 계산될 때, 우리는 Marching Tetrahedra를 적용해 triangle mesh를 추출합니다. 

서로 부호가 다른 SDF values를 가진 vertices에 대해 이 algorithm은 vertices와 surface의 교차점을 계산합니다. 이렇게 계산된 3개(또는 4개)의 verices은 최종 mesh의 vertices \( \{ v_n \} \)를 형성하며, 이들은 1개(또는 2개)의 triangle faces로 연결됩니다.

자세하게 두개의 Delaunay vertices \( \mathbf{p}_{k,i},\ \mathbf{p}_{k',j} \) 와 SDF values \( f_{k,i},\ f_{k',j} \) 을 기반으로 다음과 같이 계산합니다.
$$
\mathbf{v}_n
=
\frac{
f_{k,i}\,\mathbf{p}_{k',j}
-
f_{k',j}\,\mathbf{p}_{k,i}
}{
f_{k,i} - f_{k',j}
}
$$
이 수식으로 인하여  learnable SDF values와 Delaunay vertices을 기반으로 얻어진 mesh의 gradients가 Gaussian으로 전달되게 됩니다.

![Figure 3](./assets/img/Paper-Review/MILo/Figure3.webp)



### 5 Mesh-in-the-Loop Optimization

---

volumetric과 mesh representations를 통합하기 위해 MILo는 두 표현이 각각 렌더링한 depth와 normal maps을 비교합니다.

#### 5.1 Volumetric rendering

Gaussian을 optimization하기 위해 photometric terms과 regularization term을 결합한 loss \( L_{\mathrm{vol}} \) 을 사용합니다
$$
L_{\mathrm{vol}}
=
(1 - \lambda_{\mathrm{RGB}})\, L_1
+
\lambda_{\mathrm{RGB}}\, L_{\mathrm{D\text{-}SSIM}}
+
\lambda_N\, L_N
$$
\( L_{\mathrm{1}} \) 은 L1 loss, \( L_{\mathrm{D-SSIM}} \) 은 D-SSIM term, \( L_{\mathrm{N}} \)은 normal consistency loss 입니다. \( L_{\mathrm{N}} \) 다음과 같이 정의됩니다.
$$
L_N
=
\sum_i
\left(
1 - \mathbf{N}(i) \cdot \tilde{\mathbf{N}}(i)
\right)
$$
\( \mathbf{N}(i) \)는 volumetric rendering을 통하여 예측한 pixel i에서의 normal이며 \(\tilde{\mathbf{N}}(i)\) 은 렌더링된 depth map의 finite difference를 적용하여 얻은 pixel i에서의 normal 입니다.

해당 수식은 Gaussians들이 서로 정렬되도록 유도하고 noise를 크게 줄여줍니다.

#### 5.2 Volume-to-Surface Consistency

volumetric representation과 mesh surface의 consistency를 강제화하기 위해 다음과 같은 loss를 도입합니다.
$$
L_{\mathrm{mesh}}
=
\lambda_{\mathrm{MD}}\, L_{\mathrm{MD}}
+
\lambda_{\mathrm{MN}}\, L_{\mathrm{MN}}
$$
\(L_{\mathrm{MD}}\)는 다음과 같이 정의됩니다.
$$
L_{\mathrm{MD}}
=
\sum_i
\log \left( 1 + \left| D(i) - D_M(i) \right| \right)
$$
D는 Gaussian으로 부터 렌더링된 depth map이며 \(D_{\mathrm{M}}\)은 mesh로부터 렌더링된 depth map입니다.

\(L_{\mathrm{MN}}\)은 normal consistency loss이며 다음과 같이 정의합니다.
$$
L_{\mathrm{MN}}
=
\sum_i
\left(
1 - \tilde{\mathbf{N}}(i) \cdot \mathbf{N}_M(i)
\right)
$$
\(\mathbf{N}_M\)은 pixel i에 해당하는 mesh surface의 normal 입니다.



#### 5.3 Regularization

이전의 loss들은 효과적이지만 mesh를 재구성하는데 충분하지 않습니다. 다음과 같은 2가지 주요 과제를 해결해야 합니다.

**Erosion** tetrahedron 내부의 SDF values가 모두 양수가 되면 geometry의 미세한 부분이 침식되거나 손상됩니다. mesh rasterization의 sharp nature 때문에 mesh rendering에 antialiasing을 적용하더라도 geometry 를 복구하는 것이 어렵습니다. Erosion이 생기면 gradient signal이 약해지거나 사라지므로 surface를 복원하기 어렵습니다.

MILo는 이를 해결하기 위해 regularization term \(L_{\mathrm{erosion}}\)을 제안합니다
$$
\mathcal{L}_{\text{erosion}} = \sum_i \max(0, f_{\mu_q})
$$
\(\mathbf{G}_Del\)은 Delaunay triangulation을 위해 샘플링된 점이며  \(f_{\mu_q}\)는 Gaussian의 center 입니다. 이항은 Gaussian의 encer를 surface 안쪽으로 포함시키도록 유도하며 SDF values가 음수가 되도록 유도합니다. \(L_{\mathrm{erosion}}\)은 center에만 적용되어 mesh의 붕괴를 방지합니다.



**Interior artifacts** 이전까지의 loss는 occluded parts에 대한 적절한 제약을 제공하지 않습니다. 이로 인하여 비어있어야할 내부 공간은 무질서한 구조를 가지게 됩니다. 이러한 artifact는 mesh editing이나 물리학 시뮬레이션에서 안좋은 영향을 끼칩니다.

이를 개선하기 위해 extracted mesh와 SDF values 간의 feedback loop를 기반으로 한 새로운 loss function을 제안합니다. 이  loss는 mesh 내부에 위치한 가려진 점들이 음수 SDF values를 갖도록 강제합니다. 우리는 mesh에서 각각의 Delaunay site p를 occupancy label\( o_p \in \{0, 1\} \)로 사용합니다. 이 점들이 surface의 내부의 보이는 부분의 내부에 있는지 외부에 있는지 알 수 있습니다. 우리는 Delaunay vertices가 음수 SDF values를 갖도록 강제합니다

$$
L_{\mathrm{interior}}
=
\sum_p
H\!\left(
\sigma(-f_p),\ o_p
\right)\, o_p
$$
H 는 cross-entropy loss, \( \sigma \) 는 sigmoid function,\(f_{\mathrm{p}}\)느 Delaunay site p의 SDF values, \(o_p\)는 p의 occupancy labe을 의미합니다.

\(o_p\)을 계산하기 위해 우리는 모든 training viewpoints로 부터 mesh의 depth maps을 렌더링 합니다. 그리고나서 임의의 Delaunay site p에 대해, 만약 p가 시야에 포함하는 모든 depth map 뒤에 위치 할 경우 해당 지점을 mesh 내부로 분류합니다. occupancy labels을 업데이트하는데는 몇 초가 소요되며 200 iterations마다 수행됩니다. clean interiors을 제공하기 위한 mesh를 위해 다음과 같은 loss를 정의합니다.
$$
L
=
L_{\mathrm{vol}}
+
L_{\mathrm{mesh}}
+
L_{\mathrm{reg}}
$$

$$
L_{\mathrm{reg}}
=
\lambda_{\mathrm{erosion}}\, L_{\mathrm{erosion}}
+
\lambda_{\mathrm{interior}}\, L_{\mathrm{interior}}
$$

### 6 Experiments

---

![Figure 4](./assets/img/Paper-Review/MILo/Figure4.webp)

#### 6.1 Resources Requirements

아래 표는 어느정도의 자원을 차지하는지 보여줍니다

![Table 1](./assets/img/Paper-Review/MILo/Table1.webp)

아래 표는 F1-score 와 average optimization time를 나타냅니다

![Table 2](./assets/img/Paper-Review/MILo/Table2.webp)

아래는 정성적 비교를 나타냅니다.

![Figure 5](./assets/img/Paper-Review/MILo/Figure5.webp)

아래는 Reconstruction -> Ground truth Distance Evaluation을 나타냅니다

![Figure 6](./assets/img/Paper-Review/MILo/Figure6.webp)

#### 6.3 Mesh-Based Novel View Synthesis

MILo는 GT RGB이미지를 통한 mesh평가 방법으로 NVS를 사용합니다. mesh rendering과 GT간의 시각적 일관성을 측정함으로써 다음을 평가할 수 있습니다.

- 재구성된 표면과 GT간의 geometric artifacts
- mesh completeness
- Background reconstruction

mesh를 rendering 하기 위해 Nvidiffrast를 통하여 triangels을 rasterize 합니다. 단순한 방식으로 각 mesh vertices의 RGB 값을 할당하고 해당 값을 보간하여 픽셀의 색상을 결정할 수 있습니다. 하지만 이 방법은 해상도가 제한적이기 때문에 spare하지만 정확한 mesh의 경우 이미지 품질 저하가 될 수 있습니다. 

이를 해결하기 위해 neural color filed \( F_{\mathrm{color}} : \mathbb{R}^3 \rightarrow [0, 1]^3 \) 를 사용하여 색상과 mesh resolution을 분리하여 mesh를 texturing 합니다. 특정 pixel p에서 rendered color를 얻기 위해서 우리는 pixel p에서 rasterized된 triangle point의 3D 위치 \( \mathbf{P} \in \mathbb{R}^3 \)를 계산합니다. 이는 카메라 파라미터를 사용한 depth value를 backprojecting함으로써 얻을 수 있습니다. 그후 backprojected된 surface point에 \( F_{\mathrm{color}}\) 에 query를 던집니다. 이 mesh texturing은 color value를 vertices별이 아닌 neural field에 저장하며, 색상 할당이 mesh resolution에 독립적이도록 보장합니다.

이를 수행하기 위해 먼저 각 mesh마다 training view를 사용하여 neural field를 먼저 학습시킵니다. TensorRF를 backbone으로 채택하고 5k iteration만큼 학습시킵니다. 그리고 test view로 평가합니다. 이 metric은 mesh geometry와 image간의 정렬흘 효과적으로 정량화합니다.

아래는 NVS에서 SOTA를 달성했음을 보여줍니다.

![Table 4](./assets/img/Paper-Review/MILo/Table4.webp)

#### 6.5 Ablation Study

![Figure 7](./assets/img/Paper-Review/MILo/Figure7.webp)

![Figure 8](./assets/img/Paper-Review/MILo/Figure8.webp)

아래는 대부분의 방법론에서 사용하는 TSDDF보다 우리의 방법론이 우수함을 보여주고 있습니다

![Figure 9](./assets/img/Paper-Review/MILo/Figure9.webp)

#### 6.7 Limitations and Conclusions

아래와 같은 Limitations를 제안합니다.

1. Baseline 3dgs에 비하여 주기적인 iteration마다 mesh extraction을 수행해야 하므로 cost가 많이 듬
2. reconstruction의 quelity는 initial distribution에 달려있습니다.



